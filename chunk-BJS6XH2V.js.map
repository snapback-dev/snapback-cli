{"version":3,"sources":["../../../packages/core/dist/analysis/static/SkippedTestDetector.js"],"names":["detectSkippedTests","code","filePath","skipped","visit","node","type","callee","property","name","object","testType","arguments","length","firstArg","value","quasis","raw","push","line","loc","start","column","file","key","Object","keys","Array","isArray","item","ast","parse","sourceType","plugins","errorRecovery","program","parsed","error","Error","message","String","analyzeSkippedTests","files","results","content","includes","getSkippedTestSummary","summary","totalSkipped","byType","describe","it","test","filesWithSkipped","result"],"mappings":"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","file":"chunk-BJS6XH2V.js","sourcesContent":["/**\n * Skipped Test Detector\n *\n * Uses @babel/parser to detect skipped tests (describe.skip, it.skip, test.skip)\n * in test files. This helps AI agents identify RED PHASE TDD tests that may\n * be ready to enable.\n *\n * @module analysis/static/SkippedTestDetector\n */\nimport { parse } from \"@babel/parser\";\n/**\n * Detect skipped tests in a file's source code\n *\n * @param code - Source code to analyze\n * @param filePath - Path to file (for error reporting)\n * @returns Detection result with skipped tests\n *\n * @example\n * ```typescript\n * const result = detectSkippedTests(`\n *   describe.skip(\"Feature\", () => {\n *     it(\"should work\", () => {});\n *   });\n * `, \"feature.test.ts\");\n *\n * // result.skipped = [{ type: \"describe\", name: \"Feature\", line: 2, ... }]\n * ```\n */\nexport function detectSkippedTests(code, filePath) {\n    const skipped = [];\n    try {\n        const ast = parse(code, {\n            sourceType: \"module\",\n            plugins: [\"typescript\", \"jsx\"],\n            errorRecovery: true,\n        });\n        // Simple AST traversal without @babel/traverse (to avoid extra dependency in MCP)\n        function visit(node) {\n            if (node.type === \"CallExpression\") {\n                const callee = node.callee;\n                // Check for .skip pattern: describe.skip, it.skip, test.skip\n                if (callee.type === \"MemberExpression\" &&\n                    callee.property.type === \"Identifier\" &&\n                    callee.property.name === \"skip\" &&\n                    callee.object.type === \"Identifier\") {\n                    const testType = callee.object.name;\n                    if (testType === \"describe\" || testType === \"it\" || testType === \"test\") {\n                        // Try to extract test name from first argument\n                        let name;\n                        if (node.arguments.length > 0) {\n                            const firstArg = node.arguments[0];\n                            if (firstArg.type === \"StringLiteral\") {\n                                name = firstArg.value;\n                            }\n                            else if (firstArg.type === \"TemplateLiteral\" && firstArg.quasis.length === 1) {\n                                name = firstArg.quasis[0].value.raw;\n                            }\n                        }\n                        skipped.push({\n                            type: testType,\n                            name,\n                            line: node.loc?.start.line ?? 0,\n                            column: node.loc?.start.column ?? 0,\n                            file: filePath,\n                        });\n                    }\n                }\n                // Also check for skip() as method call: describe(\"name\", () => {}).skip\n                // This is less common but supported by some frameworks\n            }\n            // Recursively visit all properties that could contain nodes\n            for (const key of Object.keys(node)) {\n                const value = node[key];\n                if (value && typeof value === \"object\") {\n                    if (Array.isArray(value)) {\n                        for (const item of value) {\n                            if (item && typeof item === \"object\" && \"type\" in item) {\n                                visit(item);\n                            }\n                        }\n                    }\n                    else if (\"type\" in value) {\n                        visit(value);\n                    }\n                }\n            }\n        }\n        visit(ast.program);\n        return { file: filePath, skipped, parsed: true };\n    }\n    catch (error) {\n        return {\n            file: filePath,\n            skipped: [],\n            parsed: false,\n            error: error instanceof Error ? error.message : String(error),\n        };\n    }\n}\n/**\n * Analyze multiple files for skipped tests\n *\n * @param files - Map of file path to content\n * @returns Array of results for each file\n */\nexport function analyzeSkippedTests(files) {\n    const results = [];\n    for (const [filePath, content] of files) {\n        // Only analyze test files\n        if (filePath.includes(\".test.\") || filePath.includes(\".spec.\") || filePath.includes(\"__tests__\")) {\n            results.push(detectSkippedTests(content, filePath));\n        }\n    }\n    return results;\n}\n/**\n * Get summary of skipped tests across all files\n */\nexport function getSkippedTestSummary(results) {\n    const summary = {\n        totalSkipped: 0,\n        byType: { describe: 0, it: 0, test: 0 },\n        filesWithSkipped: [],\n    };\n    for (const result of results) {\n        if (result.skipped.length > 0) {\n            summary.filesWithSkipped.push(result.file);\n            summary.totalSkipped += result.skipped.length;\n            for (const test of result.skipped) {\n                summary.byType[test.type]++;\n            }\n        }\n    }\n    return summary;\n}\n"]}